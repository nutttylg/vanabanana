<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå VANABANANA - Options ATM Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üçå</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            padding: 12px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-image: url('https://i.imgur.com/your-image-url.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: -1;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
        }

        .main-content {
            flex: 1;
        }

        .trade-tape {
            width: 320px;
            background: rgba(26, 26, 26, 0.92);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            height: calc(100vh - 24px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .tape-header {
            font-size: 12px;
            font-weight: bold;
            color: #ffd43b;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        .tape-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tape-content::-webkit-scrollbar {
            width: 6px;
        }

        .tape-content::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .tape-content::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .trade-item {
            background: rgba(40, 40, 40, 0.6);
            border: 1px solid #2a2a2a;
            border-radius: 3px;
            padding: 6px;
            margin-bottom: 6px;
            font-size: 9px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .trade-item.block-trade {
            border-left: 3px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .trade-item.high-value {
            border-left: 3px solid #ffd43b;
            background: rgba(255, 212, 59, 0.1);
        }

        .trade-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .trade-symbol {
            color: #fff;
            font-size: 10px;
        }

        .trade-type {
            font-size: 8px;
            padding: 1px 4px;
            border-radius: 2px;
            background: #ff6b6b;
            color: #fff;
        }

        .trade-type.block {
            background: #ff6b6b;
        }

        .trade-type.high-value {
            background: #ffd43b;
            color: #000;
        }

        .trade-details {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 8px;
            font-size: 8px;
        }

        .trade-label {
            color: #888;
        }

        .trade-value {
            color: #fff;
            text-align: right;
        }

        .trade-value.buy {
            color: #51cf66;
        }

        .trade-value.sell {
            color: #ff6b6b;
        }

        .trade-time {
            font-size: 7px;
            color: #666;
            margin-top: 3px;
            text-align: right;
        }

        .header {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 12px;
        }

        .header-left {
            grid-column: 1 / 3;
        }

        .header-right {
            grid-column: 3 / 4;
            font-size: 8px;
            background: rgba(26, 26, 26, 0.92);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            line-height: 1.3;
        }

        h1 {
            font-size: 28px;
            color: #ffd43b;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }

        .status {
            display: flex;
            gap: 15px;
            font-size: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        .connected {
            background: #51cf66;
        }

        .disconnected {
            background: #ff6b6b;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }

        .card {
            background: rgba(26, 26, 26, 0.92);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-size: 9px;
        }

        .card-header {
            font-size: 11px;
            font-weight: bold;
            color: #ffd43b;
            margin-bottom: 6px;
            text-align: center;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }

        .expiry-date {
            font-size: 8px;
            color: #888;
            margin-top: 2px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .data-row:last-child {
            border-bottom: none;
        }

        .label {
            color: #aaa;
            font-size: 8px;
        }

        .value {
            font-size: 9px;
            font-weight: bold;
            color: #fff;
            text-align: right;
        }

        .section-separator {
            border-top: 1px solid #333;
            margin: 4px 0 2px 0;
            padding-top: 3px;
        }

        .strike {
            color: #69db7c;
        }

        .iv {
            color: #ffd43b;
        }

        .straddle {
            color: #ff8787;
        }

        .loading {
            text-align: center;
            color: #888;
            padding: 40px;
        }

        .legend-item {
            padding: 1px 0;
            line-height: 1.3;
        }

        .delta-details {
            font-size: 7px;
            color: #fff;
            margin-top: 2px;
            line-height: 1.4;
            font-weight: 500;
        }

        .delta-compact {
            display: flex;
            justify-content: space-between;
            gap: 4px;
            font-size: 7px;
            margin-top: 2px;
        }

        .delta-compact-item {
            flex: 1;
            background: rgba(40, 40, 40, 0.5);
            padding: 3px 4px;
            border-radius: 2px;
        }

        .delta-compact-call {
            border-left: 2px solid #51cf66;
        }

        .delta-compact-put {
            border-left: 2px solid #ff6b6b;
        }

        .footer {
            text-align: center;
            font-size: 10px;
            color: #555;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #222;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="header">
                <div class="header-left">
                    <h1>üçå VANABANANA</h1>
                    <div class="subtitle">ATM Options Dashboard - Real-time Volatility & Straddle Pricing</div>
                    <div class="status">
                        <span>Deribit: <span class="status-dot disconnected" id="wsStatus"></span></span>
                        <span>BTC: $<span id="btcPrice">--</span></span>
                        <span>ETH: $<span id="ethPrice">--</span></span>
                        <span>SOL: $<span id="solPrice">--</span></span>
                        <span>Updated: <span id="lastUpdate">--</span></span>
                        <span id="refreshStatus" style="color: #888;"></span>
                    </div>
                </div>
                <div class="header-right">
                    <div style="font-weight: bold; color: #ffd43b; margin-bottom: 6px;">üî• Skew Value Glossary</div>
                    <div style="display: flex; gap: 15px; font-size: 8px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <div style="color: #aaa; margin-bottom: 3px; font-style: italic;">Weekly Expiries:</div>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <span style="color: #ff4444;">üò± <-15%</span>
                                <span style="color: #ff9966;">üêª -15~-5%</span>
                                <span style="color: #69db7c;">üòé -5~+5%</span>
                                <span style="color: #ffd43b;">üêÇ +5~+10%</span>
                                <span style="color: #ff6b6b;">üöÄ >+10%</span>
                            </div>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <div style="color: #aaa; margin-bottom: 3px; font-style: italic;">Monthly & Next Month:</div>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <span style="color: #ff4444;">üò± <-12%</span>
                                <span style="color: #ff9966;">üêª -12~-5%</span>
                                <span style="color: #69db7c;">üòé -5~+3%</span>
                                <span style="color: #ffd43b;">üêÇ +3~+12%</span>
                                <span style="color: #ff6b6b;">üöÄ >+12%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="grid" id="optionsGrid">
                <div class="loading">Loading options data...</div>
            </div>

            <div class="footer">
                <div id="dateTime">--</div>
            </div>
        </div>

        <div class="trade-tape">
            <div class="tape-header">
                üìä LIVE OPTIONS TAPE
                <div style="font-size: 8px; color: #888; margin-top: 2px;">Block Trades & High Value Options (>$100k)</div>
            </div>
            <div class="tape-content" id="tapeContent">
                <div style="text-align: center; color: #666; font-size: 9px; padding: 20px;">
                    Connecting to trade feed...
                </div>
            </div>
        </div>
    </div>

    <script>
        // State management
        const state = {
            prices: {
                BTC: 0,
                ETH: 0,
                SOL: 0
            },
            currencies: {
                BTC: {
                    weekly: null,
                    monthly: null,
                    nextMonthly: null,
                    quarterly: null
                },
                ETH: {
                    weekly: null,
                    monthly: null,
                    nextMonthly: null,
                    quarterly: null
                },
                SOL: {
                    weekly: null,
                    monthly: null,
                    nextMonthly: null,
                    quarterly: null
                }
            },
            ws: null,
            trades: [],
            maxTrades: 50, // Keep last 50 trades
            baselines: null // Percentile baselines loaded from JSON
        };

        // API configuration
        const API_BASE = 'https://www.deribit.com/api/v2';
        const WS_URL = 'wss://www.deribit.com/ws/api/v2';

        // Black-Scholes calculation helpers
        function normalCDF(x) {
            // Approximation of cumulative distribution function for standard normal distribution
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            const prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            return x > 0 ? 1 - prob : prob;
        }

        function calculateBlackScholesDelta(spotPrice, strikePrice, timeToExpiry, volatility, optionType, riskFreeRate = 0.02) {
            // timeToExpiry in years
            // volatility as decimal (e.g., 0.80 for 80%)

            if (timeToExpiry <= 0) return optionType === 'call' ? 1 : -1;

            const vol = volatility / 100; // Convert percentage to decimal
            const d1 = (Math.log(spotPrice / strikePrice) + (riskFreeRate + vol * vol / 2) * timeToExpiry) / (vol * Math.sqrt(timeToExpiry));

            if (optionType === 'call') {
                return normalCDF(d1);
            } else {
                return normalCDF(d1) - 1;
            }
        }

        function compareDeltas(apiDelta, calcDelta) {
            const diff = Math.abs(apiDelta - calcDelta);
            if (diff > 0.15) return { status: 'DISCREPANCY', color: '#ff6b6b' };
            if (diff > 0.10) return { status: 'CAP', color: '#ffd43b' };
            return { status: 'OK', color: '#51cf66' };
        }

        // Percentile baselines removed - Greeks.live not working
        async function loadBaselines() {
            // Greeks.live percentiles disabled
            state.baselines = null;
            console.log('‚úì Percentile baselines disabled (Greeks.live not available)');
        }

        // Calculate percentile for a value given baselines
        function calculatePercentile(value, baselineKey) {
            if (!state.baselines || !state.baselines[baselineKey]) {
                console.warn(`‚ö†Ô∏è PERCENTILE CALC: No baseline found for ${baselineKey}`);
                return null;
            }

            const baseline = state.baselines[baselineKey];

            console.log(`\nüìä PERCENTILE CALCULATION for ${baselineKey}:`);
            console.log(`  Current value: ${value?.toFixed(2)}`);
            console.log(`  Baseline range: ${baseline.min} to ${baseline.max}`);
            console.log(`  Baseline: p10=${baseline.p10} | p25=${baseline.p25} | p50=${baseline.p50} | p75=${baseline.p75} | p90=${baseline.p90}`);

            // Calculate approximate percentile
            let percentile;
            if (value <= baseline.p10) {
                percentile = Math.max(0, 10 * (value - baseline.min) / (baseline.p10 - baseline.min));
                console.log(`  ‚Üí Value ‚â§ p10: percentile = ${percentile.toFixed(1)}%ile`);
            } else if (value <= baseline.p25) {
                percentile = 10 + 15 * (value - baseline.p10) / (baseline.p25 - baseline.p10);
                console.log(`  ‚Üí Value between p10-p25: percentile = ${percentile.toFixed(1)}%ile`);
            } else if (value <= baseline.p50) {
                percentile = 25 + 25 * (value - baseline.p25) / (baseline.p50 - baseline.p25);
                console.log(`  ‚Üí Value between p25-p50: percentile = ${percentile.toFixed(1)}%ile`);
            } else if (value <= baseline.p75) {
                percentile = 50 + 25 * (value - baseline.p50) / (baseline.p75 - baseline.p50);
                console.log(`  ‚Üí Value between p50-p75: percentile = ${percentile.toFixed(1)}%ile`);
            } else if (value <= baseline.p90) {
                percentile = 75 + 15 * (value - baseline.p75) / (baseline.p90 - baseline.p75);
                console.log(`  ‚Üí Value between p75-p90: percentile = ${percentile.toFixed(1)}%ile`);
            } else {
                percentile = Math.min(100, 90 + 10 * (value - baseline.p90) / (baseline.max - baseline.p90));
                console.log(`  ‚Üí Value > p90: percentile = ${percentile.toFixed(1)}%ile`);
            }

            return percentile;
        }

        // Get percentile context and color
        function getPercentileContext(percentile) {
            if (percentile === null || percentile === undefined) return { label: 'N/A', color: '#888' };

            if (percentile >= 90) return { label: 'EXTREME', color: '#ff6b6b' }; // Very high
            if (percentile >= 75) return { label: 'ELEVATED', color: '#ff8787' }; // High
            if (percentile >= 60) return { label: 'HIGH', color: '#ffd43b' }; // Above avg
            if (percentile >= 40) return { label: 'NORMAL', color: '#69db7c' }; // Normal
            if (percentile >= 25) return { label: 'BELOW AVG', color: '#51cf66' }; // Below avg
            if (percentile >= 15) return { label: 'LOW', color: '#4dabf7' }; // Low
            return { label: 'COMPLACENT', color: '#748ffc' }; // Very low
        }

        // Initialize
        async function init() {
            console.log('Initializing VANABANANA...');

            // Load percentile baselines
            await loadBaselines();

            // Update date/time
            updateDateTime();
            setInterval(updateDateTime, 1000);

            // Initial data fetch
            await refreshAllData();

            // Connect WebSocket for real-time updates
            connectWebSocket();

            // Auto-refresh all data every 5 minutes to recalculate delta strikes
            // Reduced frequency to avoid API rate limits
            setInterval(async () => {
                console.log('Auto-refreshing options data...');
                await refreshAllData();
            }, 300000); // 5 minutes (300 seconds)
        }

        // Refresh all options data
        async function refreshAllData() {
            const refreshStatus = document.getElementById('refreshStatus');
            if (refreshStatus) refreshStatus.textContent = 'üîÑ Refreshing delta strikes...';

            // Fetch prices for all currencies
            await Promise.all([
                fetchPrice('BTC'),
                fetchPrice('ETH'),
                fetchPrice('SOL')
            ]);

            // Fetch and categorize options for all currencies
            await Promise.all([
                fetchAndCategorizeOptions('BTC'),
                fetchAndCategorizeOptions('ETH'),
                fetchAndCategorizeOptions('SOL')
            ]);

            if (refreshStatus) {
                refreshStatus.textContent = '‚úì Auto-refresh: 5min';
                setTimeout(() => {
                    refreshStatus.textContent = '';
                }, 3000);
            }
        }

        // Fetch current price for a currency
        async function fetchPrice(currency) {
            try {
                const response = await fetch(`${API_BASE}/public/get_index_price?index_name=${currency.toLowerCase()}_usd`);
                const data = await response.json();
                state.prices[currency] = data.result.index_price;

                // Update UI prices
                if (currency === 'BTC') {
                    document.getElementById('btcPrice').textContent = state.prices.BTC.toLocaleString('en-US', {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    });
                } else if (currency === 'ETH') {
                    document.getElementById('ethPrice').textContent = state.prices.ETH.toLocaleString('en-US', {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    });
                } else if (currency === 'SOL') {
                    document.getElementById('solPrice').textContent = state.prices.SOL.toLocaleString('en-US', {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    });
                }
                console.log(`${currency} Price:`, state.prices[currency]);
            } catch (error) {
                console.error(`Error fetching ${currency} price:`, error);
            }
        }

        // Fetch and categorize options
        async function fetchAndCategorizeOptions(currency) {
            try {
                // SOL options on Deribit are USDC-settled
                const apiCurrency = currency === 'SOL' ? 'USDC' : currency;
                const response = await fetch(`${API_BASE}/public/get_instruments?currency=${apiCurrency}&kind=option&expired=false`);
                const data = await response.json();
                let instruments = data.result;

                // Filter SOL options specifically for USDC currency
                if (currency === 'SOL') {
                    instruments = instruments.filter(inst => inst.instrument_name.startsWith('SOL'));
                }

                console.log(`Fetched ${instruments.length} ${currency} options`);

                // Group by expiration
                const expirationMap = new Map();
                instruments.forEach(inst => {
                    const expiry = inst.expiration_timestamp;
                    if (!expirationMap.has(expiry)) {
                        expirationMap.set(expiry, []);
                    }
                    expirationMap.get(expiry).push(inst);
                });

                // Sort expirations
                const sortedExpiries = Array.from(expirationMap.keys()).sort((a, b) => a - b);

                // Categorize by settlement_period field
                const now = Date.now();

                // Group expirations by settlement period
                const weeklyExpiries = [];
                const monthlyExpiries = [];
                const quarterlyExpiries = [];

                expirationMap.forEach((insts, expiry) => {
                    const settlement = insts[0].settlement_period;
                    if (settlement === 'week') weeklyExpiries.push(expiry);
                    else if (settlement === 'month') monthlyExpiries.push(expiry);
                    else if (settlement === 'quarter') quarterlyExpiries.push(expiry);
                });

                // Sort each category
                weeklyExpiries.sort((a, b) => a - b);
                monthlyExpiries.sort((a, b) => a - b);
                quarterlyExpiries.sort((a, b) => a - b);

                // Find nearest in each category
                const weekly = weeklyExpiries.find(exp => exp > now);
                const monthly = monthlyExpiries.find(exp => exp > now);
                const nextMonthly = monthlyExpiries.find(exp => exp > (monthly || 0));
                const quarterly = quarterlyExpiries.find(exp => exp > now);

                // Find ATM strikes for each category
                if (weekly) state.currencies[currency].weekly = await findATMOptions(expirationMap.get(weekly), weekly, `${currency} Weekly`, currency);
                if (monthly) state.currencies[currency].monthly = await findATMOptions(expirationMap.get(monthly), monthly, `${currency} Monthly`, currency);
                if (nextMonthly) state.currencies[currency].nextMonthly = await findATMOptions(expirationMap.get(nextMonthly), nextMonthly, `${currency} Next Monthly`, currency);
                if (quarterly) state.currencies[currency].quarterly = await findATMOptions(expirationMap.get(quarterly), quarterly, `${currency} Quarterly`, currency);

                // Render UI only after all currencies are loaded
                if (Object.values(state.currencies).every(c => c.weekly || c.monthly)) {
                    renderUI();
                }

            } catch (error) {
                console.error('Error fetching options:', error);
            }
        }

        // Find ATM options for a given expiration
        async function findATMOptions(instruments, expiry, label, currency) {
            const currentPrice = state.prices[currency];

            // Find closest strike to current price
            const strikes = [...new Set(instruments.map(i => i.strike))].sort((a, b) => a - b);
            const atmStrike = strikes.reduce((prev, curr) =>
                Math.abs(curr - currentPrice) < Math.abs(prev - currentPrice) ? curr : prev
            );

            // Find call and put at ATM strike
            const call = instruments.find(i => i.strike === atmStrike && i.option_type === 'call');
            const put = instruments.find(i => i.strike === atmStrike && i.option_type === 'put');

            if (!call || !put) return null;

            // Fetch ticker data for ATM options
            const callTicker = await fetchTicker(call.instrument_name);
            const putTicker = await fetchTicker(put.instrument_name);

            // Get ATM IV for normalization
            const atmIV = callTicker?.mark_iv || null;

            // Find 25 delta and 15 delta options for skew calculation
            const skews = await calculateSkews(instruments, currency, expiry, atmIV);

            return {
                currency,
                label,
                expiry,
                expiryDate: new Date(expiry).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }),
                strike: atmStrike,
                call: {
                    name: call.instrument_name,
                    price: callTicker?.mark_price || 0,
                    iv: callTicker?.mark_iv || 0
                },
                put: {
                    name: put.instrument_name,
                    price: putTicker?.mark_price || 0,
                    iv: putTicker?.mark_iv || 0
                },
                atmIV: callTicker?.mark_iv || 0,
                straddlePrice: (callTicker?.mark_price || 0) + (putTicker?.mark_price || 0),
                skew25: skews?.skew25 || null,
                skew15: skews?.skew15 || null,
                call25d: skews?.call25d || null,
                put25d: skews?.put25d || null,
                call15d: skews?.call15d || null,
                put15d: skews?.put15d || null
            };
        }

        // Helper to batch requests with delay
        async function batchFetch(items, batchSize, delayMs, expiry, currency) {
            const results = [];
            const currentPrice = state.prices[currency];
            const timeToExpiry = (expiry - Date.now()) / (1000 * 60 * 60 * 24 * 365); // Convert to years

            for (let i = 0; i < items.length; i += batchSize) {
                const batch = items.slice(i, i + batchSize);
                const batchResults = await Promise.all(
                    batch.map(async item => {
                        const ticker = await fetchTicker(item.instrument_name);

                        // Calculate Black-Scholes delta
                        let calculatedDelta = null;
                        if (ticker && ticker.mark_iv) {
                            calculatedDelta = calculateBlackScholesDelta(
                                currentPrice,
                                item.strike,
                                timeToExpiry,
                                ticker.mark_iv,
                                item.option_type
                            );
                        }

                        return {
                            ...item,
                            ticker,
                            calculatedDelta
                        };
                    })
                );
                results.push(...batchResults);

                // Delay between batches to avoid rate limiting
                if (i + batchSize < items.length) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
            return results;
        }

        // Calculate delta skews
        async function calculateSkews(instruments, currency, expiry, atmIV) {
            const currentPrice = state.prices[currency];
            const calls = instruments.filter(i => i.option_type === 'call');
            const puts = instruments.filter(i => i.option_type === 'put');

            // Only fetch a subset of strikes around where 25Œî/15Œî should be
            // For calls: strikes above current price, sorted ascending (closest to ATM first)
            // For puts: strikes below current price, sorted descending (closest to ATM first)
            // EXPANDED RANGE to ensure we capture 20-30Œî and 10-20Œî options
            const callsSubset = calls
                .filter(c => c.strike >= currentPrice * 1.01 && c.strike <= currentPrice * 2.00)
                .sort((a, b) => a.strike - b.strike) // Sort ascending
                .slice(0, 50); // 50 strikes - more coverage for delta ranges

            const putsSubset = puts
                .filter(p => p.strike <= currentPrice * 0.99 && p.strike >= currentPrice * 0.50)
                .sort((a, b) => b.strike - a.strike) // Sort descending (highest to lowest)
                .slice(0, 50); // 50 strikes

            console.log(`${currency}: Fetching ${callsSubset.length} calls (${callsSubset[0]?.strike}-${callsSubset[callsSubset.length-1]?.strike}) and ${putsSubset.length} puts (${putsSubset[0]?.strike}-${putsSubset[putsSubset.length-1]?.strike})`);

            // Fetch tickers with batching and delays - VERY SMALL batches, LONG delays to avoid 429 errors
            const tickeredOptions = await batchFetch([...callsSubset, ...putsSubset], 4, 1000, expiry, currency);

            // Find 25 delta options (delta ‚âà 0.25 for calls, ‚âà -0.25 for puts)
            const callsWithDelta = tickeredOptions.filter(o => o.option_type === 'call' && o.ticker?.greeks?.delta);
            const putsWithDelta = tickeredOptions.filter(o => o.option_type === 'put' && o.ticker?.greeks?.delta);

            // Log all deltas for debugging (API vs Calculated)
            console.log(`${currency} Call deltas:`, callsWithDelta.map(c => ({
                strike: c.strike,
                apiDelta: c.ticker.greeks.delta.toFixed(3),
                calcDelta: c.calculatedDelta?.toFixed(3) || 'N/A',
                diff: c.calculatedDelta ? Math.abs(c.ticker.greeks.delta - c.calculatedDelta).toFixed(3) : 'N/A'
            })));

            console.log(`${currency} Put deltas:`, putsWithDelta.map(p => ({
                strike: p.strike,
                apiDelta: p.ticker.greeks.delta.toFixed(3),
                calcDelta: p.calculatedDelta?.toFixed(3) || 'N/A',
                diff: p.calculatedDelta ? Math.abs(p.ticker.greeks.delta - p.calculatedDelta).toFixed(3) : 'N/A',
                distanceFrom25d: Math.abs(p.ticker.greeks.delta + 0.25).toFixed(3)
            })));

            // Find 25 delta options - use bracket approach (0.20-0.30 for calls, -0.30 to -0.20 for puts)
            // If no candidates in primary range, expand to 0.15-0.35 / -0.35 to -0.15 as fallback
            let call25dCandidates = callsWithDelta.filter(c => c.ticker.greeks.delta >= 0.20 && c.ticker.greeks.delta <= 0.30);
            let put25dCandidates = putsWithDelta.filter(p => p.ticker.greeks.delta <= -0.20 && p.ticker.greeks.delta >= -0.30);

            console.log(`${currency} 25Œî Candidates (primary): ${call25dCandidates.length} calls, ${put25dCandidates.length} puts`);

            // Fallback: expand range if no candidates found
            if (call25dCandidates.length === 0) {
                call25dCandidates = callsWithDelta.filter(c => c.ticker.greeks.delta >= 0.15 && c.ticker.greeks.delta <= 0.35);
                console.log(`${currency} 25Œî Calls (fallback): ${call25dCandidates.length} candidates`);
            }
            if (put25dCandidates.length === 0) {
                put25dCandidates = putsWithDelta.filter(p => p.ticker.greeks.delta <= -0.15 && p.ticker.greeks.delta >= -0.35);
                console.log(`${currency} 25Œî Puts (fallback): ${put25dCandidates.length} candidates`);
            }

            const call25d = call25dCandidates.reduce((prev, curr) =>
                !prev || Math.abs(curr.ticker.greeks.delta - 0.25) < Math.abs(prev.ticker.greeks.delta - 0.25)
                ? curr : prev
            , null);

            const put25d = put25dCandidates.reduce((prev, curr) =>
                !prev || Math.abs(curr.ticker.greeks.delta + 0.25) < Math.abs(prev.ticker.greeks.delta + 0.25)
                ? curr : prev
            , null);

            // Find 15 delta options - use bracket approach (0.10-0.20 for calls, -0.20 to -0.10 for puts)
            // Ensure we don't use the same strike as 25 delta
            let call15dCandidates = tickeredOptions.filter(o =>
                o.option_type === 'call' &&
                o.ticker?.greeks?.delta &&
                o.ticker.greeks.delta >= 0.10 &&
                o.ticker.greeks.delta < 0.20 &&
                o.strike !== call25d?.strike  // Ensure different strike from 25Œî
            );

            let put15dCandidates = tickeredOptions.filter(o =>
                o.option_type === 'put' &&
                o.ticker?.greeks?.delta &&
                o.ticker.greeks.delta <= -0.10 &&
                o.ticker.greeks.delta > -0.20 &&
                o.strike !== put25d?.strike  // Ensure different strike from 25Œî
            );

            console.log(`${currency} 15Œî Candidates (primary): ${call15dCandidates.length} calls, ${put15dCandidates.length} puts`);

            // Fallback: expand range if no candidates found (0.05-0.25 for calls, -0.25 to -0.05 for puts)
            if (call15dCandidates.length === 0) {
                call15dCandidates = tickeredOptions.filter(o =>
                    o.option_type === 'call' &&
                    o.ticker?.greeks?.delta &&
                    o.ticker.greeks.delta >= 0.05 &&
                    o.ticker.greeks.delta < 0.25 &&
                    o.strike !== call25d?.strike
                );
                console.log(`${currency} 15Œî Calls (fallback): ${call15dCandidates.length} candidates`);
            }

            if (put15dCandidates.length === 0) {
                put15dCandidates = tickeredOptions.filter(o =>
                    o.option_type === 'put' &&
                    o.ticker?.greeks?.delta &&
                    o.ticker.greeks.delta <= -0.05 &&
                    o.ticker.greeks.delta > -0.25 &&
                    o.strike !== put25d?.strike
                );
                console.log(`${currency} 15Œî Puts (fallback): ${put15dCandidates.length} candidates`);
            }

            const call15d = call15dCandidates.reduce((prev, curr) =>
                !prev || Math.abs(curr.ticker.greeks.delta - 0.15) < Math.abs(prev.ticker.greeks.delta - 0.15)
                ? curr : prev
            , null);

            const put15d = put15dCandidates.reduce((prev, curr) =>
                !prev || Math.abs(curr.ticker.greeks.delta + 0.15) < Math.abs(prev.ticker.greeks.delta + 0.15)
                ? curr : prev
            , null);

            // Debug logging with API vs Calculated deltas
            console.log(`${currency} 25Œî Skew Debug:`, {
                call: call25d ? `${call25d.instrument_name} - Strike: $${call25d.strike} | API Œî=${call25d.ticker.greeks.delta.toFixed(3)} | Calc Œî=${call25d.calculatedDelta?.toFixed(3) || 'N/A'} | IV=${call25d.ticker.mark_iv.toFixed(2)}%` : 'N/A',
                put: put25d ? `${put25d.instrument_name} - Strike: $${put25d.strike} | API Œî=${put25d.ticker.greeks.delta.toFixed(3)} | Calc Œî=${put25d.calculatedDelta?.toFixed(3) || 'N/A'} | IV=${put25d.ticker.mark_iv.toFixed(2)}%` : 'N/A',
                currentPrice: `$${currentPrice.toFixed(2)}`
            });

            console.log(`${currency} 15Œî Skew Debug:`, {
                call: call15d ? `${call15d.instrument_name} - Strike: $${call15d.strike} | API Œî=${call15d.ticker.greeks.delta.toFixed(3)} | Calc Œî=${call15d.calculatedDelta?.toFixed(3) || 'N/A'} | IV=${call15d.ticker.mark_iv.toFixed(2)}%` : 'N/A',
                put: put15d ? `${put15d.instrument_name} - Strike: $${put15d.strike} | API Œî=${put15d.ticker.greeks.delta.toFixed(3)} | Calc Œî=${put15d.calculatedDelta?.toFixed(3) || 'N/A'} | IV=${put15d.ticker.mark_iv.toFixed(2)}%` : 'N/A'
            });

            // Calculate Risk Reversal: (Call IV - Put IV) / ATM IV * 100
            // Greeks.live formula - mark_iv is in % (70 = 70%), ratio needs *100 to convert back to %
            const skew25 = (put25d?.ticker?.mark_iv && call25d?.ticker?.mark_iv && atmIV)
                ? ((call25d.ticker.mark_iv - put25d.ticker.mark_iv) / atmIV) * 100
                : null;

            const skew15 = (put15d?.ticker?.mark_iv && call15d?.ticker?.mark_iv && atmIV)
                ? ((call15d.ticker.mark_iv - put15d.ticker.mark_iv) / atmIV) * 100
                : null;

            // DEBUG: Log skew calculation details
            if (skew25 !== null) {
                console.log(`\nüîç ${currency} SKEW25 CALCULATION DEBUG:`);
                console.log(`  Call 25Œî IV: ${call25d.ticker.mark_iv.toFixed(2)}%`);
                console.log(`  Put 25Œî IV: ${put25d.ticker.mark_iv.toFixed(2)}%`);
                console.log(`  ATM IV: ${atmIV.toFixed(2)}%`);
                console.log(`  Difference: ${(call25d.ticker.mark_iv - put25d.ticker.mark_iv).toFixed(2)}%`);
                console.log(`  Skew25 = (${call25d.ticker.mark_iv.toFixed(2)} - ${put25d.ticker.mark_iv.toFixed(2)}) / ${atmIV.toFixed(2)} * 100`);
                console.log(`  Skew25 = ${skew25.toFixed(2)}%`);
            }

            return {
                skew25,
                skew15,
                call25d: call25d ? {
                    strike: call25d.strike,
                    iv: call25d.ticker.mark_iv,
                    delta: call25d.ticker.greeks.delta,
                    calculatedDelta: call25d.calculatedDelta,
                    comparison: call25d.calculatedDelta ? compareDeltas(call25d.ticker.greeks.delta, call25d.calculatedDelta) : null
                } : null,
                put25d: put25d ? {
                    strike: put25d.strike,
                    iv: put25d.ticker.mark_iv,
                    delta: put25d.ticker.greeks.delta,
                    calculatedDelta: put25d.calculatedDelta,
                    comparison: put25d.calculatedDelta ? compareDeltas(put25d.ticker.greeks.delta, put25d.calculatedDelta) : null
                } : null,
                call15d: call15d ? {
                    strike: call15d.strike,
                    iv: call15d.ticker.mark_iv,
                    delta: call15d.ticker.greeks.delta,
                    calculatedDelta: call15d.calculatedDelta,
                    comparison: call15d.calculatedDelta ? compareDeltas(call15d.ticker.greeks.delta, call15d.calculatedDelta) : null
                } : null,
                put15d: put15d ? {
                    strike: put15d.strike,
                    iv: put15d.ticker.mark_iv,
                    delta: put15d.ticker.greeks.delta,
                    calculatedDelta: put15d.calculatedDelta,
                    comparison: put15d.calculatedDelta ? compareDeltas(put15d.ticker.greeks.delta, put15d.calculatedDelta) : null
                } : null
            };
        }

        // Get skew context (Risk Reversal ranges)
        function getSkewContext(skew, expiryType = 'weekly') {
            if (skew === null || skew === undefined) return { label: 'N/A', color: '#888' };

            const isWeekly = expiryType === 'weekly';

            // Weekly thresholds
            if (isWeekly) {
                if (skew < -15) return { label: 'EXTREME FEAR', color: '#ff4444' };
                if (skew < -5) return { label: 'SMOLTING BERA', color: '#ff9966' };
                if (skew < 5) return { label: 'CHILL', color: '#69db7c' };
                if (skew < 10) return { label: 'PUNPY', color: '#ffd43b' };
                return { label: 'EUPHORIA', color: '#ff6b6b' };
            }

            // Monthly & Next Month thresholds
            if (skew < -12) return { label: 'EXTREME FEAR', color: '#ff4444' };
            if (skew < -5) return { label: 'SMOLTING BERA', color: '#ff9966' };
            if (skew < 3) return { label: 'CHILL', color: '#69db7c' };
            if (skew < 12) return { label: 'PUNPY', color: '#ffd43b' };
            return { label: 'EUPHORIA', color: '#ff6b6b' };
        }

        // Fetch ticker data
        async function fetchTicker(instrumentName) {
            try {
                const response = await fetch(`${API_BASE}/public/ticker?instrument_name=${instrumentName}`);
                const data = await response.json();
                return data.result;
            } catch (error) {
                console.error(`Error fetching ticker for ${instrumentName}:`, error);
                return null;
            }
        }

        // Format straddle range
        function formatStraddleRange(straddleUSD, currentPrice) {
            const lower = currentPrice - straddleUSD;
            const upper = currentPrice + straddleUSD;

            // Smart formatting based on price levels
            if (currentPrice >= 10000) {
                // BTC range: show as $XXk - $XXk with 1 decimal
                return `$${(lower / 1000).toFixed(1)}k - $${(upper / 1000).toFixed(1)}k`;
            } else if (currentPrice >= 1000) {
                // ETH range: show full numbers with commas
                return `$${Math.round(lower).toLocaleString()} - $${Math.round(upper).toLocaleString()}`;
            } else {
                // SOL range: show full numbers with 2 decimals
                return `$${lower.toFixed(2)} - $${upper.toFixed(2)}`;
            }
        }

        // Render UI (3x3 matrix: BTC/ETH/SOL rows, Weekly/Monthly/Next columns)
        function renderUI() {
            const grid = document.getElementById('optionsGrid');
            grid.innerHTML = '';

            const currencies = ['BTC', 'ETH', 'SOL'];
            const categories = ['weekly', 'monthly', 'nextMonthly']; // Skip quarterly for 3x3 grid

            currencies.forEach(currency => {
                categories.forEach(cat => {
                    const data = state.currencies[currency][cat];
                    if (!data) {
                        // Add placeholder if data not available
                        const placeholder = document.createElement('div');
                        placeholder.className = 'card';
                        placeholder.innerHTML = '<div class="loading">Loading...</div>';
                        grid.appendChild(placeholder);
                        return;
                    }

                    const currentPrice = state.prices[currency];

                const card = document.createElement('div');
                card.className = 'card';

                // SOL options are USDC-settled, so prices are already in USD
                const isUsdcSettled = currency === 'SOL';
                const callPriceDisplay = isUsdcSettled
                    ? `$${data.call.price.toFixed(2)}`
                    : `${data.call.price.toFixed(4)} ${currency} ($${(data.call.price * currentPrice).toLocaleString('en-US', {maximumFractionDigits: 0})})`;
                const putPriceDisplay = isUsdcSettled
                    ? `$${data.put.price.toFixed(2)}`
                    : `${data.put.price.toFixed(4)} ${currency} ($${(data.put.price * currentPrice).toLocaleString('en-US', {maximumFractionDigits: 0})})`;
                const straddlePriceDisplay = isUsdcSettled
                    ? `$${data.straddlePrice.toFixed(2)}`
                    : `${data.straddlePrice.toFixed(4)} ${currency} ($${(data.straddlePrice * currentPrice).toLocaleString('en-US', {maximumFractionDigits: 0})})`;

                card.innerHTML = `
                    <div class="card-header">
                        ${data.label}
                        <div class="expiry-date">${data.expiryDate}</div>
                    </div>
                    <div class="data-row">
                        <span class="label">ATM Strike</span>
                        <span class="value strike">$${data.strike.toLocaleString()}</span>
                    </div>
                    <div class="data-row">
                        <span class="label">ATM IV</span>
                        <span class="value iv">${data.atmIV.toFixed(2)}%</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Expected Daily Move</span>
                        <span class="value">${(() => {
                            const dailyMove = (currentPrice * (data.atmIV / 100)) / Math.sqrt(365);
                            if (currentPrice >= 10000) {
                                return `$${(dailyMove / 1000).toFixed(2)}k (${((dailyMove / currentPrice) * 100).toFixed(2)}%)`;
                            } else if (currentPrice >= 1000) {
                                return `$${Math.round(dailyMove).toLocaleString()} (${((dailyMove / currentPrice) * 100).toFixed(2)}%)`;
                            } else {
                                return `$${dailyMove.toFixed(2)} (${((dailyMove / currentPrice) * 100).toFixed(2)}%)`;
                            }
                        })()}</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Call Price</span>
                        <span class="value">${callPriceDisplay}</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Put Price</span>
                        <span class="value">${putPriceDisplay}</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Straddle Price</span>
                        <span class="value straddle">${straddlePriceDisplay}</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Straddle Range</span>
                        <span class="value">${isUsdcSettled ? formatStraddleRange(data.straddlePrice, currentPrice) : formatStraddleRange(data.straddlePrice * currentPrice, currentPrice)}</span>
                    </div>
                    <div class="section-separator"></div>
                    <div class="data-row">
                        <span class="label">25Œî Skew (RR)</span>
                        <span class="value">
                            <span title="${data.skew25 !== null && data.put25d && data.call25d ?
                                `Formula: (Call IV - Put IV) / ATM IV √ó 100\n` +
                                `Call 25Œî IV: ${data.call25d.iv ? data.call25d.iv.toFixed(2) + '%' : 'N/A'}\n` +
                                `Put 25Œî IV: ${data.put25d.iv ? data.put25d.iv.toFixed(2) + '%' : 'N/A'}\n` +
                                `ATM IV: ${data.atmIV ? data.atmIV.toFixed(2) + '%' : 'N/A'}\n` +
                                `= (${data.call25d.iv ? data.call25d.iv.toFixed(2) : '?'} - ${data.put25d.iv ? data.put25d.iv.toFixed(2) : '?'}) / ${data.atmIV ? data.atmIV.toFixed(2) : '?'} √ó 100\n` +
                                `= ${data.skew25.toFixed(2)}%`
                                : 'Skew calculation data not available'}"
                                style="cursor: help; border-bottom: 1px dotted #666;">
                                ${data.skew25 !== null ? data.skew25.toFixed(2) + '%' : '--'}
                            </span>
                            <span style="color: ${getSkewContext(data.skew25, cat).color}; font-size: 10px;">[${getSkewContext(data.skew25, cat).label}]</span>
                        </span>
                    </div>
                    <div style="font-size: 6px; color: #666; margin: 2px 0; padding: 2px 4px; background: rgba(255,255,255,0.03); border-radius: 2px;">
                        ${cat === 'weekly' ?
                            '<-15% | -15~-5% | -5~+5% | +5~+10% | >+10%' :
                            '<-12% | -12~-5% | -5~+3% | +3~+12% | >+12%'}
                    </div>
                    ${(data.call25d || data.put25d) ? `
                    <div class="delta-compact">
                        ${data.call25d ? `<div class="delta-compact-item delta-compact-call">
                            <strong>C:</strong> $${data.call25d.strike.toLocaleString()} | Œî:${data.call25d.delta.toFixed(3)} (${data.call25d.calculatedDelta?.toFixed(3) || 'N/A'}) ${data.call25d.comparison ? `<span style="color: ${data.call25d.comparison.color}; font-weight: bold;">[${data.call25d.comparison.status}]</span>` : ''}
                        </div>` : ''}
                        ${data.put25d ? `<div class="delta-compact-item delta-compact-put">
                            <strong>P:</strong> $${data.put25d.strike.toLocaleString()} | Œî:${data.put25d.delta.toFixed(3)} (${data.put25d.calculatedDelta?.toFixed(3) || 'N/A'}) ${data.put25d.comparison ? `<span style="color: ${data.put25d.comparison.color}; font-weight: bold;">[${data.put25d.comparison.status}]</span>` : ''}
                        </div>` : ''}
                    </div>
                    ` : ''}
                    <div class="section-separator"></div>
                    <div class="data-row">
                        <span class="label">15Œî Skew (RR)</span>
                        <span class="value">
                            <span title="${data.skew15 !== null && data.put15d && data.call15d ?
                                `Formula: (Call IV - Put IV) / ATM IV √ó 100\n` +
                                `Call 15Œî IV: ${data.call15d.iv ? data.call15d.iv.toFixed(2) + '%' : 'N/A'}\n` +
                                `Put 15Œî IV: ${data.put15d.iv ? data.put15d.iv.toFixed(2) + '%' : 'N/A'}\n` +
                                `ATM IV: ${data.atmIV ? data.atmIV.toFixed(2) + '%' : 'N/A'}\n` +
                                `= (${data.call15d.iv ? data.call15d.iv.toFixed(2) : '?'} - ${data.put15d.iv ? data.put15d.iv.toFixed(2) : '?'}) / ${data.atmIV ? data.atmIV.toFixed(2) : '?'} √ó 100\n` +
                                `= ${data.skew15.toFixed(2)}%`
                                : 'Skew calculation data not available'}"
                                style="cursor: help; border-bottom: 1px dotted #666;">
                                ${data.skew15 !== null ? data.skew15.toFixed(2) + '%' : '--'}
                            </span>
                            <span style="color: ${getSkewContext(data.skew15, cat).color}; font-size: 10px;">[${getSkewContext(data.skew15, cat).label}]</span>
                        </span>
                    </div>
                    ${(data.call15d || data.put15d) ? `
                    <div class="delta-compact">
                        ${data.call15d ? `<div class="delta-compact-item delta-compact-call">
                            <strong>C:</strong> $${data.call15d.strike.toLocaleString()} | Œî:${data.call15d.delta.toFixed(3)} (${data.call15d.calculatedDelta?.toFixed(3) || 'N/A'}) ${data.call15d.comparison ? `<span style="color: ${data.call15d.comparison.color}; font-weight: bold;">[${data.call15d.comparison.status}]</span>` : ''}
                        </div>` : ''}
                        ${data.put15d ? `<div class="delta-compact-item delta-compact-put">
                            <strong>P:</strong> $${data.put15d.strike.toLocaleString()} | Œî:${data.put15d.delta.toFixed(3)} (${data.put15d.calculatedDelta?.toFixed(3) || 'N/A'}) ${data.put15d.comparison ? `<span style="color: ${data.put15d.comparison.color}; font-weight: bold;">[${data.put15d.comparison.status}]</span>` : ''}
                        </div>` : ''}
                    </div>
                    ` : ''}
                `;
                    grid.appendChild(card);
                });
            });

            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Connect WebSocket
        function connectWebSocket() {
            state.ws = new WebSocket(WS_URL);

            state.ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('wsStatus').className = 'status-dot connected';

                // Subscribe to price indices
                state.ws.send(JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'public/subscribe',
                    params: {
                        channels: [
                            'deribit_price_index.btc_usd',
                            'deribit_price_index.eth_usd',
                            'deribit_price_index.sol_usd'
                        ]
                    },
                    id: 1
                }));

                // Subscribe to all ATM option tickers
                const channels = [];
                Object.keys(state.currencies).forEach(currency => {
                    Object.values(state.currencies[currency]).forEach(exp => {
                        if (exp) {
                            channels.push(`ticker.${exp.call.name}.100ms`);
                            channels.push(`ticker.${exp.put.name}.100ms`);
                        }
                    });
                });

                if (channels.length > 0) {
                    state.ws.send(JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'public/subscribe',
                        params: { channels },
                        id: 2
                    }));
                }

                // Note: WebSocket trades for individual options would require subscribing to each instrument
                // Instead, we'll poll for block trades using the REST API
                console.log('‚úì WebSocket connected - using REST API polling for block trades');
            };

            state.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.params && data.params.channel) {
                    handleWebSocketUpdate(data.params);
                }
            };

            state.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('wsStatus').className = 'status-dot disconnected';
            };

            state.ws.onclose = () => {
                console.log('WebSocket closed, reconnecting in 5s...');
                document.getElementById('wsStatus').className = 'status-dot disconnected';
                setTimeout(connectWebSocket, 5000);
            };
        }

        // Handle WebSocket updates
        function handleWebSocketUpdate(params) {
            const channel = params.channel;
            const data = params.data;

            // Price index updates
            if (channel === 'deribit_price_index.btc_usd') {
                state.prices.BTC = data.price;
                document.getElementById('btcPrice').textContent = state.prices.BTC.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                return;
            }
            if (channel === 'deribit_price_index.eth_usd') {
                state.prices.ETH = data.price;
                document.getElementById('ethPrice').textContent = state.prices.ETH.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                return;
            }
            if (channel === 'deribit_price_index.sol_usd') {
                state.prices.SOL = data.price;
                document.getElementById('solPrice').textContent = state.prices.SOL.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                return;
            }

            // Trade updates
            if (channel.startsWith('trades.')) {
                // data is an array of trades
                if (Array.isArray(data)) {
                    data.forEach(trade => processTrade(trade));
                }
                return;
            }

            // Ticker update
            if (channel.startsWith('ticker.')) {
                const instrumentName = data.instrument_name;

                // Update the corresponding option data
                Object.keys(state.currencies).forEach(currency => {
                    Object.keys(state.currencies[currency]).forEach(cat => {
                        const exp = state.currencies[currency][cat];
                        if (!exp) return;

                        if (exp.call.name === instrumentName) {
                            exp.call.price = data.mark_price;
                            exp.call.iv = data.mark_iv;
                            exp.atmIV = data.mark_iv;
                            exp.straddlePrice = exp.call.price + exp.put.price;
                        } else if (exp.put.name === instrumentName) {
                            exp.put.price = data.mark_price;
                            exp.put.iv = data.mark_iv;
                            exp.straddlePrice = exp.call.price + exp.put.price;
                        }
                    });
                });

                renderUI();
            }
        }

        // Process incoming trade
        function processTrade(trade) {
            // Calculate USD notional value correctly
            // For Deribit options: price = premium in underlying (BTC/ETH), amount = number of contracts
            const symbol = trade.instrument_name.split('-')[0];
            const currentPrice = state.prices[symbol] || 0;
            const usdNotional = trade.price * trade.amount * currentPrice;

            // Filter: Show ALL block trades (no threshold) OR high value trades (>$100k)
            const isBlockTrade = (trade.block_trade_id !== undefined && trade.block_trade_id !== null && trade.block_trade_id !== "");
            const isBlockRFQ = (trade.block_rfq_id !== undefined && trade.block_rfq_id !== null && trade.block_rfq_id !== "");
            const isHighValue = usdNotional > 100000;

            // Prioritize block trades - show all of them regardless of size
            if (!isBlockTrade && !isBlockRFQ && !isHighValue) {
                return; // Skip this trade
            }

            console.log('‚úÖ Block/High-Value Trade:', {
                instrument: trade.instrument_name,
                contracts: trade.amount,
                premium: `${trade.price.toFixed(4)} ${symbol}`,
                usdNotional: `$${usdNotional.toLocaleString()}`,
                block_trade_id: trade.block_trade_id,
                block_rfq_id: trade.block_rfq_id,
                isBlockTrade,
                isBlockRFQ,
                isHighValue
            });

            // Add to trades array
            const tradeData = {
                ...trade,
                usdNotional,
                isBlockTrade,
                isHighValue,
                timestamp: trade.timestamp || Date.now()
            };

            state.trades.unshift(tradeData);

            // Keep only last maxTrades
            if (state.trades.length > state.maxTrades) {
                state.trades.pop();
            }

            // Render trade tape
            renderTradeTape();
        }

        // Render trade tape
        function renderTradeTape() {
            const tapeContent = document.getElementById('tapeContent');

            if (state.trades.length === 0) {
                tapeContent.innerHTML = '<div style="text-align: center; color: #666; font-size: 9px; padding: 20px;">Waiting for trades...</div>';
                return;
            }

            tapeContent.innerHTML = state.trades.map(trade => {
                // Parse instrument name: BTC-29NOV24-95000-C
                const parts = trade.instrument_name.split('-');
                const symbol = parts[0]; // BTC, ETH, SOL
                const expiry = parts[1]; // 29NOV24
                const strike = parts[2] ? `$${parseInt(parts[2]).toLocaleString()}` : ''; // 95000
                const type = parts[3] === 'C' ? 'CALL' : 'PUT'; // C or P

                const time = new Date(trade.timestamp).toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                const classes = ['trade-item'];
                if (trade.isBlockTrade) classes.push('block-trade');
                if (trade.isHighValue) classes.push('high-value');

                let typeLabel = '';
                let typeClass = '';
                if (trade.isBlockTrade) {
                    typeLabel = 'BLOCK';
                    typeClass = 'block';
                } else if (trade.isHighValue) {
                    typeLabel = 'HIGH VALUE';
                    typeClass = 'high-value';
                }

                // For Deribit options:
                // - price = premium per contract in underlying currency (BTC/ETH/SOL)
                // - amount = number of contracts (e.g., 10, 50, 100)
                // - USD notional = price √ó amount √ó current_underlying_price
                const currentPrice = state.prices[symbol] || 0;
                const contracts = trade.amount; // Number of contracts
                const premiumPerContract = trade.price; // In BTC/ETH/SOL
                const usdNotional = premiumPerContract * contracts * currentPrice;

                const premiumLabel = symbol === 'BTC' ? `${premiumPerContract.toFixed(4)} BTC` :
                                     symbol === 'ETH' ? `${premiumPerContract.toFixed(4)} ETH` :
                                     `${premiumPerContract.toFixed(4)} ${symbol}`;

                return `
                    <div class="${classes.join(' ')}">
                        <div class="trade-header">
                            <span class="trade-symbol">${symbol} ${strike} ${type}</span>
                            <span class="trade-type ${typeClass}">${typeLabel}</span>
                        </div>
                        <div class="trade-details">
                            <span class="trade-label">Expiry:</span>
                            <span class="trade-value">${expiry}</span>

                            <span class="trade-label">Side:</span>
                            <span class="trade-value ${trade.direction}">${trade.direction.toUpperCase()}</span>

                            <span class="trade-label">Contracts:</span>
                            <span class="trade-value">${contracts.toLocaleString('en-US', { maximumFractionDigits: 1 })}</span>

                            <span class="trade-label">Premium:</span>
                            <span class="trade-value">${premiumLabel}</span>

                            <span class="trade-label">USD Value:</span>
                            <span class="trade-value">$${usdNotional.toLocaleString('en-US', { maximumFractionDigits: 0 })}</span>
                        </div>
                        <div class="trade-time">${time}</div>
                    </div>
                `;
            }).join('');
        }

        // Update date/time
        function updateDateTime() {
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }).toUpperCase();
            const timeStr = now.toLocaleTimeString('en-GB');
            document.getElementById('dateTime').textContent = `${dateStr} ${timeStr}`;
        }

        // Poll for block trades using REST API
        async function pollBlockTrades() {
            try {
                // Fetch recent trades for BTC, ETH, and SOL options
                const currencies = ['BTC', 'ETH', 'SOL'];

                for (const currency of currencies) {
                    const response = await fetch(`https://www.deribit.com/api/v2/public/get_last_trades_by_currency?currency=${currency}&kind=option&count=100&include_old=false`);
                    const data = await response.json();

                    if (data.result && data.result.trades) {
                        data.result.trades.forEach(trade => {
                            // Only process if it's a block trade or high value
                            if (trade.block_trade_id || trade.block_rfq_id || trade.amount > 100000) {
                                // Check if we already have this trade (avoid duplicates)
                                const exists = state.trades.some(t =>
                                    t.trade_id === trade.trade_id ||
                                    (t.timestamp === trade.timestamp && t.instrument_name === trade.instrument_name)
                                );

                                if (!exists) {
                                    processTrade(trade);
                                }
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error polling block trades:', error);
            }
        }

        // Start polling for block trades every 10 seconds
        setInterval(pollBlockTrades, 10000);

        // Initial poll
        setTimeout(pollBlockTrades, 3000); // Wait 3 seconds after page load

        // Start the app
        init();
    </script>
</body>
</html>
